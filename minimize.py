# Python library to compute the SOP minimization of a given boolean
# function

__author__ = "Josh Pfosi"

import math # for log

# Args: func - string defining minterms and don't cares
# Returns: dict w/ ones and dc elements
# Notes: This correctly parses desired input but will fail silently on
# poorly formed input
def parse_func(func):
    # remove all whitespace characters
    func = ''.join(func.split())

    ones = func
    dcs  = []

    if "+" in func:
        (ones, dcs) = func.split('+')
        dcs  = [int(i) for i in dcs[2:-1].split(',')]

    # list comprehension to remove 'm(' and ')'
    # and cast to array of integers
    ones = [int(i) for i in ones[2:-1].split(',')]

    return (ones, dcs)

def nice_print(result=[]):
    numVars = len(result[0])

    if numVars < 1 or numVars > 10: 
        sys.stderr.write("Cannot handle more than 10 variables or less than 1 variable\n")
        return

    # hard code special case where all minterms are covered
    if len(result) == 1 and len(result[0].replace("X", "")) == 0:
        print "=1\n=1"
        return

    variables = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J']

    sop = pos = ""

    for epi in result:
        pos += "("

        while epi.endswith("X"): epi = epi[:-1] # leave off trailing dont cares

        for i, lit in enumerate(epi): # use enumerate to expose i
            if lit is "X": continue

            if lit is "1": 
                sop += variables[i]
                pos += "%s'+" % variables[i]
            elif lit is "0":
                sop += "%s'" % variables[i]
                pos += "%s+" % variables[i]

        sop += "+"
        pos = pos[:-1] + ")" # replace last plus with ')'

    sop = sop[:-1]

    print "=%s" % sop
    print "=%s" % pos

#def numOnes(dec):         return len(re.sub('[0b]', '', bin(dec)))
#def withinPowerTwo(n, m): 
#    print "%d - %d > 0 and 2^(log(%d), 2) == %d" % (m, n, m-n, m-n)
#    return m - n > 0 and 2**math.floor(math.log(m - n, 2)) == m - n

# Args: low, high - two binary strings such as '0001' and '0010'
# Returns true if they can be legally combined - if dcs match, and minterms within power of two
# Note: Always pass "lower" PI as first arg
def combine(low, high):
    lowLen  = len(low)
    highLen = len(high)
    
    if lowLen != highLen: raise "Cannot combine implicants of different length"

    combo = ''
    diff  = 0
    for i in range(lowLen):
        if low[i] is high[i]: combo += low[i]
        else:
            combo += "X"
            diff  += 1

    if diff > 1: return None
    
    return combo

# Args: nCubes - array of string representing n-cubes
# Returns an array of all the prime implicants generated by recursing
# on that list
def generatePis(nCubes):
    size = len(nCubes)

    if size is 0: return []

    nextNCubes = []
    pis        = []
    pis        += nCubes # they all start unmarked

    # iterate over all n-cubes, combining and marking if differing by only 1 bit
    for i in range(size):
        for j in range (i + 1, size):
            combination = combine(nCubes[i], nCubes[j])

            if combination is not None:
                # duplicates don't get added twice
                if combination not in nextNCubes: nextNCubes += [combination]

                # "check" off implicants only once
                if nCubes[i] in pis:              pis.remove(nCubes[i])
                if nCubes[j] in pis:              pis.remove(nCubes[j])

    morePis = generatePis(nextNCubes)

    return pis + morePis

# Args: pi - converts input of form "-01-" to the minterms that it defines
# Returns list of minerms e.g. [1,2,3,4]
def literalsToMinterms(pi):
    size = len(pi)
    minterms = range(2**size) # all minterms are possible - now eliminate

    # compare each bit of the pi, to the respective bit in each minterm
    for i in range(size): # for each bit in pi
        if pi[i] is "X": continue

        for m in range(2**size): # for each possible minterm
            binary = bin(m)[2:].zfill(size)
            if (m in minterms and binary[i] is not pi[i]): minterms.remove(m)

    return minterms

def mintermsToLiterals(minterms, numVars):
    size = len(minterms)
    # if null list or size isn't a power of two, return
    if size == 0 or (size & (size - 1)) != 0: return ''

    binaryMintermLists = [list(bin(m)[2:].zfill(numVars)) for m in minterms]

    zipped = []
    for i in range(numVars):
        zipElem = []
        for binary in binaryMintermLists:
            zipElem += [binary[i]]
        zipped += [zipElem]


    l = ''
    for ithBitSet in zipped:
        if len(set(ithBitSet)) == 1: l += ithBitSet[0]
        else: l += "X"

    return l

# Args: ones - the minterms of the function
#       dcs  - the don't cares of the function
# Returns: array of strings representing close cover
#          e.g. { '1X0', 'XX0', ... }
# Notes: All minterms which are not in ones or dcs are assumed zeros
# This interface is deliberately similar to the qm library for testing purposes
def minimize(ones=[], dc=[]):
    if len(ones) < 1:
        sys.stderr.write("ones array too short (ones=%s)\n" % ones)
        return {}

    # round up the log_2 of the highest minterm or dont care
    # TODO should be max() + 1
    numVars   = int(math.ceil(math.log(max(ones+dc), 2)))

    # represent all minterms as binary strings padded w/ leading 0s
    zeroCubes = [bin(i)[2:].zfill(numVars) for i in ones+dc]

    nonEpis = [literalsToMinterms(pi) for pi in generatePis(zeroCubes)]
    print "nonEpis=%s" % nonEpis
    # prime implicants as lists of minterms

    #
    # Form close cover
    #

    # everything started uncovered
    uncovered = list(ones)
    epis      = []

    # initialize empty dict to store number of covers for a given minterm
    while uncovered is not []:
        coveredBy = {}
        for minterm in uncovered: coveredBy[minterm] = []

        for pi in nonEpis:
            for minterm in pi:
                # only count minterms that haven't been covered, not dont cares
                if minterm in uncovered: coveredBy[minterm] += [pi]

        foundEpi = False
        for minterm in uncovered:
            if len(coveredBy[minterm]) == 1: # only covered by one prime implicant, so EPI
                epis += coveredBy[minterm]
                nonEpis.remove(coveredBy[minterm][0]) 

                for minterm in coveredBy[minterm][0]:  # check all minterms EPI covers
                    if minterm in uncovered: uncovered.remove(minterm)
                foundEpi = True

        if not foundEpi: break

    # petrick's method!
    if uncovered != []:
        sys.stderr.write("Punting on Petrick's method (uncovered != [])\n")
        print "uncovered=%s" % uncovered
        # uncovered is a list of the minterms not covered by EPIs

        # coveredBy is an dictionary of arrays of prime implicants indexed by the
        # minterm those prime implicants cover
        # e.g. {0: [[0, 1], [0, 2]], 1: [[0, 1], [1, 5]], 2: [[0, 2], [2, 6]], 
        #       5: [[1, 5], [5, 7]], 6: [[2, 6], [6, 7]], 7: [[5, 7], [6, 7]]} 
        print "coveredBy=%s" % coveredBy

        # create an array of all the PIs which cover the uncovered minterms
        flatCoveredBy = []
        for minterm in uncovered:
            for pi in coveredBy[minterm]:
                if pi not in flatCoveredBy: flatCoveredBy += [pi]

        print "flatCoveredBy=%s" % flatCoveredBy

        if len(flatCoveredBy) > 26: print "Cannot handle more than 26 prime implicants for Petrick's method"

        # labels for each PI in Petrick's method
        labels = [chr(i + ord('A')) for i in range(len(flatCoveredBy))]

        # array of costs for each PI, in same order as labels
        costs  = [numVars - log(len(pi), 2) for pi in flatCoveredBy]
        print "costs=%s" % costs

        #
        # Form Petrick equation based on PIs
        #

        expressions = ["(" for i in range(len(uncovered))] 
        # array to represent Petrick equation e.g. ["(A | B)", "(C | ~D)"]...

        for i, pi in enumerate(flatCoveredBy):
            for j, minterm in enumerate(uncovered):
                if minterm in pi: # the pi covers that minterm
                    expressions[j] += labels[i]
                    expressions[j] += " | "

        equation = ""
        for i in range(len(expressions)):
            expressions[i] = expressions[i][:-3] # remove trailing " | "
            expressions[i] += ")"
            equation += expressions[i]
            equation += " & "

        equation = equation[:-3] # remove trailing " & "
        print "equation=%s" % equation

        # NOTE: If equation is only one term sum term, it cannot be simplified,
        # and doing so introduces a bug - detect this and short circuit

        products = []
        if "&" in equation: # more than one term
            simplified = str(simplify_logic(equation, 'dnf'))[3:-1] # leave only And terms

            simplified = ''.join(simplified.split()).replace(',','').split('And')

            print "simplified=%s" % simplified

            for term in simplified:
                print "term=%s" % term

                if len(term) > 0:
                    if term.endswith(")"): products += [term[1:-1]] # remove parens
                    else: products += [term]

            print "products=%s" % products
        else: products = equation[1:-1].split(" | ") # only one term

        #
        # Find cheapest term
        #

        product_costs = [0 for i in range(len(products))]
        for i, product in enumerate(products):
            for pi in product:
                product_costs[i] += costs[ord(pi) - ord('A')]
            product_costs[i] += 1 # for and gate

        # products_costs: e.g. [9, 9, 7, 9, 7] - array of costs for each product term
        # so choose min cost term
        minCostTerms = []

        for i, product_cost in enumerate(product_costs):
            if product_cost == min(product_costs): minCostTerms.append(products[i])
        
        print "minCostTerms=%s" % minCostTerms

        #
        # Add minCostTerms PIs as EPIs
        #

        setOfEpis = [list(epis) for i in range(len(minCostTerms))]

        for i, term in enumerate(minCostTerms):
            for pi in term:
                print "pi=%s, term=%s, i=%s flatCoveredBy=%s" % (pi, term, i, flatCoveredBy[ord(pi) - ord('A')])
                # convert label back into list of minterms it labels, and add to EPIs
                setOfEpis[i] += [flatCoveredBy[ord(pi) - ord('A')]]
        
        print "setOfEpis=%s" % setOfEpis
        return [[mintermsToLiterals(pi, numVars) for pi in epis] for epis in setOfEpis]

    return [[mintermsToLiterals(pi, numVars) for pi in epis]]


if __name__ == "__main__":
    import qm
    import sys
    import re
    import math
    from sympy import *
    from numpy.random import randint
    from numpy import unique

    for func in sys.stdin:
        (ones, dc) = parse_func(func)

        # calculate both
        lib_res    = qm.qm(ones=ones, dc=dc)
        minimizations = minimize(ones=ones, dc=dc)
        # returns an array of minimizations if multiple same cost terms exist

        # ensure order doesn't matter
        lib_res.sort()
        for minimization in minimizations: minimization.sort()

        if any([result == lib_res for result in minimizations]):
            print minimizations[0]
            nice_print(minimizations[0])
        else:
            print "Results differed"
            print "minimizations=%s" % minimizations
            print "lib_res=%s" % lib_res

        # test and print
        #if lib_res == minimizations:
        #  sys.stdout.write(".")
        #else:
        #  sys.stdout.write("F")
        #  sys.stdout.write(": Failed on func = |%s|" % func)


