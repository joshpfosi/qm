# Python library to compute the SOP minimization of a given boolean
# function

__author__ = "Josh Pfosi"

import qm
import sys
import re
from math         import *
from sympy        import *
from numpy.random import randint
from numpy        import unique
from itertools    import product

# -----------------------------------------------------------------------------
# parseFunc
# Args: func - string defining minterms and don't cares
# Returns: dict w/ ones and dc elements
#
# Notes: This correctly parses desired input but will fail silently on
# poorly formed input
# -----------------------------------------------------------------------------

def parseFunc(func):
    func = ''.join(func.split()) # remove all whitespace characters

    ones = func
    dcs  = []

    if "+" in func:
        (ones, dcs) = func.split('+')
        dcs  = [int(i) for i in dcs[2:-1].split(',')]

    # remove 'm(' and ')' and cast to integers
    ones = [int(i) for i in ones[2:-1].split(',')]

    return (ones, dcs)

# -----------------------------------------------------------------------------
# nicePrint
# Args:    result  - array of strings defining minterms and don't cares
#                    e.g. ['011X', '000X']
#          sop     - boolean to toggle SOP or POS format for printing
#          numVars - number of variables in original fxn
# Returns: nothing
#
# Notes: Prints in SOP or POS form
# -----------------------------------------------------------------------------

def nicePrint(result=[], numVars=0, sop=True):
    if numVars < 1 or numVars > 10: 
        sys.stderr.write("Cannot handle more than 10 variables or less than 1 variable\n")
        return

    # hard code special case where all minterms are covered
    if len(result) == 1 and len(result[0].replace("X", "")) == 0:
        print "=1"
        return

    variables = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J']
    eq = ''

    for epi in result:
        if not sop: eq += "("

        while epi.endswith("X"): epi = epi[:-1] # leave off trailing dont cares

        if sop:
            for i, lit in enumerate(epi):
                if lit is "X": continue

                eq += variables[i]
                if lit is "0": eq += "'"
            eq += "+" 
        else:
            for i, lit in enumerate(epi):
                if lit is "X": continue

                eq += variables[i] + "+"
                if lit is "1": eq = eq[:-1] + "'+"

            eq = eq[:-1] + ")" # replace last plus with ')'

    if sop: eq = eq[:-1]

    print "=%s" % eq

# -----------------------------------------------------------------------------
# combine
# Args:    low, high - two binary strings such as '0001' and '0010'
# Returns: True if they can be legally combined i.e. if dcs match, and minterms 
#          within power of two
#          Otherwise, returns None
#
# Note: Always pass "lower" PI as first arg
# -----------------------------------------------------------------------------

def combine(low, high):
    lowLen  = len(low)
    highLen = len(high)

    if lowLen != highLen: raise "Cannot combine implicants of different length"

    combo = ''
    diff  = 0
    for i in range(lowLen):
        if low[i] is high[i]: combo += low[i]
        else:
            combo += "X"
            diff  += 1

    if diff > 1: return None # if they differ by more than 1 bit
    else:        return combo

# -----------------------------------------------------------------------------
# generatePis
# Args:    nCubes - array of string representing n-cubes
# Returns: array of all the prime implicants generated by recursing
#          on that list
# -----------------------------------------------------------------------------

def generatePis(nCubes):
    size = len(nCubes)

    if size is 0: return []

    nextNCubes = []
    pis        = []
    pis        += nCubes # they all start unmarked

    # iterate over all n-cubes, combining and marking if differing by only 1 bit
    for i in range(size):
        for j in range (i + 1, size):
            combination = combine(nCubes[i], nCubes[j])

            if combination is not None:
                # duplicates don't get added twice
                if combination not in nextNCubes: nextNCubes += [combination]

                # "check" off implicants only once
                if nCubes[i] in pis: pis.remove(nCubes[i])
                if nCubes[j] in pis: pis.remove(nCubes[j])

    return pis + generatePis(nextNCubes)

# -----------------------------------------------------------------------------
# literalsToMinterms
# Args:    pi - string, e.g. "-01-"
# Returns: list of minerms e.g. [1,2,3,4]
# -----------------------------------------------------------------------------

def literalsToMinterms(pi):
    size = len(pi)
    minterms = range(2**size) # all minterms are possible - now eliminate

    # compare each bit of the pi, to the respective bit in each minterm
    for i in range(size): # for each bit in pi
        if pi[i] is "X": continue

        for m in range(2**size): # for each possible minterm
            binary = bin(m)[2:].zfill(size)
            if (m in minterms and binary[i] is not pi[i]): minterms.remove(m)

    return minterms

# -----------------------------------------------------------------------------
# mintermsToLiterals
# Args:    list of minerms e.g. [1,2,3,4]
# Returns: pi - string, e.g. "-01-"
# -----------------------------------------------------------------------------

def mintermsToLiterals(minterms, numVars):
    size = len(minterms)

    # if null list or size isn't a power of two, return
    if size == 0 or (size & (size - 1)) != 0: return ''

    # map minterms to binary e.g. [1,2,3,4] => ['0001','0010','0011','0100']
    binaryMintermLists = [list(bin(m)[2:].zfill(numVars)) for m in minterms]

    # take list of binary values and form array of arrays where the ith subarray
    # contains all the ith bits of all the binary values
    # e.g. ['0001','0010','0011','0100'] => 
    #      [[0,0,0,0],[0,0,0,1],[0,1,1,0],[1,0,1,0]]
    zipped = []
    for i in range(numVars):
        zipElem = []
        for binary in binaryMintermLists:
            zipElem += [binary[i]]

        zipped += [zipElem]


    literal = ''
    for ithBitSet in zipped:
        # if all the same, then just put that value, otherwise its a dc
        if len(set(ithBitSet)) == 1: literal += ithBitSet[0]
        else: literal += "X"

    return literal

# -----------------------------------------------------------------------------
# dominated
# Args:    list1 - list to find in list2
#          list2 - list in which to find sublist
# Returns: True iff all the elements in list1 are in list2
# -----------------------------------------------------------------------------

def dominated(list1, list2): return list1 == [i for i in list1 if i in list2]

# -----------------------------------------------------------------------------
# solvePetrick
# Args:    epis - current set of EPIs
#          uncovered - current set of minterms which are not covered by epis
#          coveredBy - dict of which nonEPIs cover which minterms in uncovered
#          numVars   - number of variables in original function
# Returns: one minimum cost term
# -----------------------------------------------------------------------------

def solvePetrick(epis, uncovered, coveredBy, numVars):
    # uncovered is a list of the minterms not covered by EPIs

    # coveredBy is an dictionary of arrays of prime implicants indexed by the
    # minterm those prime implicants cover
    # e.g. {0: [[0, 1], [0, 2]], 1: [[0, 1], [1, 5]], 2: [[0, 2], [2, 6]], 
    #       5: [[1, 5], [5, 7]], 6: [[2, 6], [6, 7]], 7: [[5, 7], [6, 7]]} 

    closeCovers = [list(cover) for cover in product(*coveredBy.values())]
    costs       = []
    for i, cover in enumerate(closeCovers):
        # uniq-ify all close covers
        uniqCover    = []
        costsOfCover = []
        for implicant in cover:
            if implicant not in uniqCover:
                uniqCover    += [implicant]
                costsOfCover += [numVars - log(len(implicant), 2)]
        closeCovers[i] = uniqCover
        costs += [sum(costsOfCover) + len(costsOfCover)] # each cubes cost + or gate

    minCostTerm = []
    minCost = min(costs)
    for i, cost in enumerate(costs):
        if cost == minCost: minCostTerm = closeCovers[i]

    epis += [minCostTerm]
    return [mintermsToLiterals(pi, numVars) for pi in epis]

# -----------------------------------------------------------------------------
# minimize
# Args:    ones - the minterms of the function
#          dcs  - the don't cares of the function
# Returns: array of strings representing close cover
#          e.g. { '1X0', 'XX0', ... }
#
# Notes: All minterms which are not in ones or dcs are assumed zeros
# This interface is deliberately similar to the qm library for testing purposes
# -----------------------------------------------------------------------------

def minimize(ones=[], dc=[], numVars=0):
    if len(ones) < 1:
        sys.stderr.write("ones array too short (ones=%s) or numVars too low (numVars=%s)\n" % (ones, numVars))
        return {}

    # represent all minterms as binary strings padded w/ leading 0s
    zeroCubes = [bin(i)[2:].zfill(numVars) for i in ones+dc]

    nonEpis = [literalsToMinterms(pi) for pi in generatePis(zeroCubes)]
    # prime implicants as lists of minterms

    # -------------------------------------------------------------------------
    # Form close cover
    # -------------------------------------------------------------------------
    uncovered = list(ones)
    epis      = []

    while uncovered is not []:
        # initialize empty dict to store number of covers for a given minterm
        coveredBy = {}
        for minterm in uncovered: coveredBy[minterm] = [] 

        for pi in nonEpis:
            for minterm in pi:
                # only count minterms that haven't been covered, not dont cares
                if minterm in uncovered: coveredBy[minterm] += [pi]

        # ---------------------------------------------------------------------
        # Search for EPIs
        # ---------------------------------------------------------------------
        foundEpi = False
        for minterm in uncovered:
            if len(coveredBy[minterm]) == 1: # only covered by one prime implicant, so EPI
                epis += coveredBy[minterm]
                nonEpis.remove(coveredBy[minterm][0]) 

                for minterm in coveredBy[minterm][0]:  # check all minterms EPI covers
                    if minterm in uncovered: uncovered.remove(minterm)
                foundEpi = True

        # ---------------------------------------------------------------------
        # Find dominating rows
        # ---------------------------------------------------------------------
        if not foundEpi:
            foundDomRow = False
            for minterm in uncovered:
                size = len(coveredBy[minterm])
                for i in range(size):
                    for j in range(i + 1, size):
                        pi1 = coveredBy[minterm][i]
                        pi2 = coveredBy[minterm][j]
                        l1 = [x for x in pi1 if x in uncovered]
                        l2 = [x for x in pi2 if x in uncovered]

                        if dominated(l2, l1):
                            if pi2 in nonEpis: nonEpis.remove(pi2)
                            foundDomRow = True
                        elif dominated(l1, l2):
                            if pi1 in nonEpis: nonEpis.remove(pi1)
                            foundDomRow = True
            # no dominating rows, but uncovered PIs so try Petrick's
            if not foundDomRow: break 

    # -------------------------------------------------------------------------
    # Petrick's method!
    # -------------------------------------------------------------------------
    if uncovered != []: return solvePetrick(epis, uncovered, coveredBy, numVars)
    else:               return [mintermsToLiterals(pi, numVars) for pi in epis]

# -----------------------------------------------------------------------------
# Main
# -----------------------------------------------------------------------------

if __name__ == "__main__":

    for func in sys.stdin:
        (ones, dcs) = parseFunc(func)
        numvars     = int(ceil(log(max(ones+dcs) + 1, 2)))

        # ---------------------------------------------------------------------
        # Compute SOP
        # ---------------------------------------------------------------------
        minimization = minimize(ones, dcs, numvars)
        nicePrint(minimization, numvars, sop=True)

        zeros = [maxterm for maxterm in range(2**numvars) if maxterm not in ones]
        dcs   = [dc for dc in dcs if dc not in zeros]

        # ---------------------------------------------------------------------
        # Compute POS
        # ---------------------------------------------------------------------
        minimization = minimize(zeros, dcs, numvars)
        nicePrint(minimization, numvars, sop=False)

